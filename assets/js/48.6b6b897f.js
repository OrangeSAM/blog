(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{355:function(t,a,e){"use strict";e.r(a);var v=e(3),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"起步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#起步"}},[t._v("#")]),t._v(" 起步")]),t._v(" "),e("h3",{attrs:{id:"移动开发技术简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移动开发技术简介"}},[t._v("#")]),t._v(" 移动开发技术简介")]),t._v(" "),e("p",[t._v("三种跨平台技术")]),t._v(" "),e("ol",[e("li",[t._v("H5+原生（Cordova、Ionic、微信小程序）")]),t._v(" "),e("li",[t._v("JavaScript 开发+原生渲染 （React Native、Weex、快应用）")]),t._v(" "),e("li",[t._v("自绘 UI+原生(QT for mobile、Flutter)")])]),t._v(" "),e("p",[t._v("hybrid 技术\nH5+ 原生混合开发")]),t._v(" "),e("ul",[e("li",[t._v("通过诸如 Webview 的原生网页加载控件来加载 App 中的动态变动内容。我们称这种 h5+原生的开发模式为混合开发 ，采用混合模式开发的 APP 我们称之为混合应用或 Hybrid APP ，如果一个应用的大多数功能都是 H5 实现的话，我们称其为 Web APP 。")]),t._v(" "),e("li",[t._v("把依赖于 WebView 的用于在 JavaScript 与原生之间通信并实现了某种消息传输协议的工具称之为 WebView JavaScript Bridge, 简称 "),e("strong",[t._v("JsBridge")]),t._v("，它也是混合开发框架的核心。")])]),t._v(" "),e("p",[t._v("React Native")]),t._v(" "),e("ul",[e("li",[t._v("RN 中的虚拟 DOM 会通过 JavaScriptCore 映射为原生控件树。")])]),t._v(" "),e("p",[t._v("Weex")]),t._v(" "),e("p",[t._v("快应用")]),t._v(" "),e("ul",[e("li",[t._v("原生 JS 开发")])]),t._v(" "),e("p",[t._v("自绘 UI ＋原生\n注意，自绘引擎解决的是 UI 的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。")]),t._v(" "),e("h3",{attrs:{id:"初识-flutter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初识-flutter"}},[t._v("#")]),t._v(" 初识 Flutter")]),t._v(" "),e("p",[t._v("flutter 使用 skia 作为他的 2D 渲染引擎.")]),t._v(" "),e("p",[t._v("目前,程序主要有两中国运行方式, 静态编译 和 动态解释.静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为 AOT （Ahead of time）即 “提前编译”(C C++)；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为 JIT（Just-in-time）即“即时编译”(JS python)。")]),t._v(" "),e("h3",{attrs:{id:"dart-语言简介-面向对象-动态类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart-语言简介-面向对象-动态类型"}},[t._v("#")]),t._v(" Dart 语言简介(面向对象 动态类型)")]),t._v(" "),e("h4",{attrs:{id:"变量声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量声明"}},[t._v("#")]),t._v(" 变量声明")]),t._v(" "),e("ul",[e("li",[t._v("一旦复制, 类型即确定且不可改变.")]),t._v(" "),e("li",[t._v("object 是 dart 所有对象的根基类, 即所有类型都是 object 的字类,包括 function 和 null, 所以任何类型的数据都可以复制给 object 声明的对象.")]),t._v(" "),e("li",[t._v("dynamic 与 var 一样都是关键词,声明的变量可以赋值任意对象。 而 dynamic 与 Object 相同之处在于,他们声明的变量可以在后期改变赋值类型。")]),t._v(" "),e("li",[t._v("dynamic 与 Object 不同的是,dynamic 声明的对象编译器会提供所有可能的组合, 而 Object 声明的对象只能使用 Object 的属性与方法, 否则编译器会报错。")]),t._v(" "),e("li",[t._v("final & const\n声明一个值不会变的变量, 使用 final 或 const. 一个 final 变量只能被设置一次，两者区别在于：const 变量是一个编译时常量，final 变量在第一次使用时被初始化。")])]),t._v(" "),e("h4",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),e("ol",[e("li",[t._v("函数是对象, 类型为 function,")]),t._v(" "),e("li",[t._v("函数可以赋值给变量")]),t._v(" "),e("li",[t._v("可以作为参数传递给其他函数.")]),t._v(" "),e("li",[t._v("函数声明需要声明返回值类型, 不声明默认为 dynamic, 且没有类型推断")]),t._v(" "),e("li",[t._v("支持箭头函数")]),t._v(" "),e("li",[t._v("可选的位置参数, 用[]标记")]),t._v(" "),e("li",[t._v("可选的命名参数, 用{}标记")])]),t._v(" "),e("h4",{attrs:{id:"异步支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步支持"}},[t._v("#")]),t._v(" 异步支持")]),t._v(" "),e("p",[t._v("future, 可理解为 JS 的 promise, 表示一个异步操作的最终状态标识.")]),t._v(" "),e("h2",{attrs:{id:"第一个-flutter-应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一个-flutter-应用"}},[t._v("#")]),t._v(" 第一个 flutter 应用")]),t._v(" "),e("h3",{attrs:{id:"计数器示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计数器示例"}},[t._v("#")]),t._v(" 计数器示例")]),t._v(" "),e("ul",[e("li",[t._v("Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。")]),t._v(" "),e("li",[t._v("home为flutter应用的首页，它也是一个widget。")]),t._v(" "),e("li",[t._v("MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。")]),t._v(" "),e("li",[t._v("StatefulWidget类 表示他是一个有状态的组件，即可以拥有状态，且这些状态在widget生命周期中是可以变得。")]),t._v(" "),e("li",[t._v("Stateful widget至少有两个类组成\n"),e("ul",[e("li",[t._v("一个StatefulWidget 类")]),t._v(" "),e("li",[t._v("一个State类，StatefulWidget 类本身是不变的，但是state类中持有的状态在widget生命周期中可能发生变化。")]),t._v(" "),e("li",[t._v("scaffold是material库中提供的页面脚手架，他提供了默认的导航栏、标题和包含主屏幕widget树的body属性。")])])])]),t._v(" "),e("h3",{attrs:{id:"路由管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由管理"}},[t._v("#")]),t._v(" 路由管理")]),t._v(" "),e("ul",[e("li",[t._v("路由在移动开发中通常指页面，这跟web开发中单页应用的Router概念意义是相同的。")]),t._v(" "),e("li",[t._v("MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。")]),t._v(" "),e("li",[t._v("Navigator是一个路由管理的组件，他提供了打开和退出路由页的方法。通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。\n"),e("ul",[e("li",[t._v("future push (BuildContext, Route route)\n"),e("ul",[e("li",[t._v("将给定的路由入栈，返回值是一个future对象，用以接手新路由出栈（关闭）时的返回数据。")])])]),t._v(" "),e("li",[t._v("bool pop(BuildContext context, [result])\n"),e("ul",[e("li",[t._v("将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。")])])])])])])])}),[],!1,null,null,null);a.default=_.exports}}]);